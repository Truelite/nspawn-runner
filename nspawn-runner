#!/usr/bin/env python3

from __future__ import annotations
from typing import Optional, List
import argparse
import logging
import subprocess
import os
import sys
import shlex
import shutil

log = logging.getLogger("nspawn-runner")


class Fail(RuntimeError):
    """
    Exception raised when the program should exit with an error but without a
    backtrace
    """
    pass


class Success(Exception):
    """
    Exception raised when a command has been successfully handled, and no
    further processing should happen
    """
    pass


#
# Backend implementation
#

class NspawnRunner:
    """
    Common nspawn-runner implementation, subclassed for traditional filesystem
    and btrfs filesystems
    """
    def __init__(self, root_dir: str):
        self.root_dir = root_dir
        self.gitlab_build_dir = os.path.join(self.root_dir, ".build")
        self.gitlab_cache_dir = os.path.join(self.root_dir, ".cache")

    @classmethod
    def create(cls, root_dir: str):
        """
        Instantiate the right NspawnRunner subclass for this sytem
        """
        # Detect filesystem type
        res = subprocess.run(
                ["stat", "-f", "-c", "%T", root_dir],
                check=True, text=True, stdout=subprocess.PIPE)
        fstype = res.stdout.strip()
        if fstype == "btrfs":
            return BtrfsRunner(root_dir)
        else:
            return OverlayRunner(root_dir)

    def setup(self):
        """
        Make sure all needed work directories exist
        """
        os.makedirs(self.root_dir, exist_ok=True)
        os.makedirs(self.gitlab_build_dir, exist_ok=True)
        os.makedirs(self.gitlab_cache_dir, exist_ok=True)

    def get_machine(self, run_id: str) -> "Machine":
        """
        Create a Machine object to manage a CI run
        """
        raise NotImplementedError(f"{self.__class__.__name__}.get_machine not implemented")

    def get_chroot(self, image_name: str) -> "Chroot":
        """
        Create a Run object to manage a CI chroot
        """
        raise NotImplementedError(f"{self.__class__.__name__}.get_chroot not implemented")


class Machine:
    """
    Manage a CI machine
    """
    def __init__(self, nspawn_runner: NspawnRunner, run_id: str):
        self.nspawn_runner = nspawn_runner
        self.run_id = run_id
        self.machine_name = f"run-{self.run_id}"

    def _run_nspawn(self, cmd: List[str]):
        """
        Run the given systemd-nspawn command line, contained into its own unit
        using systemd-run

        It uses exec, so this function, when successful, never returns and
        destroys the calling process
        """
        unit_config = [
            'KillMode=mixed',
            'Type=notify',
            'RestartForceExitStatus=133',
            'SuccessExitStatus=133',
            'Slice=machine.slice',
            'Delegate=yes',
            'TasksMax=16384',
            'WatchdogSec=3min',
        ]

        systemd_run_cmd = ["systemd-run"]
        for c in unit_config:
            systemd_run_cmd.append(f"--property={c}")

        systemd_run_cmd.extend(cmd)

        log.info("Running %s", " ".join(shlex.quote(c) for c in systemd_run_cmd))
        os.execvp(systemd_run_cmd[0], systemd_run_cmd)

    def start(self, chroot: "Chroot"):
        """
        Start this machine on the given chroot

        The last start command is run with exec, so this function, when
        successful, never returns and destroys the calling process
        """
        raise NotImplementedError(f"{self.__class__.__name__}.start not implemented")

    def run(self, shell: str, script: str):
        """
        Run the given script inside the machine, using the given shell

        The last command is run with exec, so this function, when
        successful, never returns and destroys the calling process
        """
        cmd = [
            "systemd-run", "--quiet", "--pipe", "--wait",
            f"--machine={self.machine_name}", shell
        ]

        log.info("Running %s", " ".join(shlex.quote(c) for c in cmd))
        with open(script, "rb") as fd:
            res = subprocess.run(cmd, stdin=fd)

        if res.returncode != 0:
            raise Fail(f"Run script exited with code {res.returncode}")

    def terminate(self):
        """
        Terminate this machine
        """
        raise NotImplementedError(f"{self.__class__.__name__}.terminate not implemented")


class OverlayMachine(Machine):
    """
    Machine implemenation for traditional filesystems
    """
    def __init__(self, *args, **kw):
        super().__init__(*args, **kw)
        self.overlay_dir = os.path.join(self.nspawn_runner.overlays_dir, self.machine_name)

    def start(self, chroot: "Chroot"):
        log.info("Starting machine using image %s", chroot.image_name)
        if os.path.exists(self.overlay_dir):
            raise Fail(f"overlay directory {self.overlay_dir} already exists")
        os.makedirs(self.overlay_dir, exist_ok=True)

        self._run_nspawn(
            ("systemd-nspawn",
                "--quiet",
                f"--directory={chroot.chroot_dir}",
                f"--overlay={chroot.chroot_dir}:{self.overlay_dir}:/",
                f"--machine={self.machine_name}",
                "--boot",
                "--notify-ready=yes")
        )

    def terminate(self):
        try:
            res = subprocess.run(["machinectl", "terminate", self.machine_name])
            if res.returncode != 0:
                raise Fail(f"Run script exited with code {res.returncode}")
        finally:
            if os.path.exists(self.overlay_dir):
                shutil.rmtree(self.overlay_dir)


class BtrfsMachine(Machine):
    """
    Machine implementation for btrfs fileystems
    """
    def start(self, chroot: "Chroot"):
        log.info("Starting machine using image %s", chroot.image_name)

        self._run_nspawn(
            ("systemd-nspawn",
                "--quiet",
                "--ephemeral",
                f"--directory={chroot.chroot_dir}",
                f"--machine={self.machine_name}",
                "--boot",
                "--notify-ready=yes")
        )

    def terminate(self):
        res = subprocess.run(["machinectl", "terminate", self.machine_name])
        if res.returncode != 0:
            raise Fail(f"Run script exited with code {res.returncode}")


class Chroot:
    """
    Manage a CI chroot
    """
    def __init__(self, nspawn_runner: NspawnRunner, image_name: str):
        self.nspawn_runner = nspawn_runner
        self.image_name = image_name
        self.chroot_dir = os.path.join(nspawn_runner.root_dir, self.image_name)

    def must_exist(self):
        """
        Raise Fail if the chroot does not already exist
        """
        if not os.path.exists(self.chroot_dir):
            available = sorted(x for x in os.listdir(self.root_dir) if not x.startswith("."))
            raise Fail(f"{self.chroot_dir} does not exist. Use one of {', '.join(available)}")

    def must_not_exist(self):
        """
        Raise Fail if the chroot does already exists
        """
        if os.path.exists(self.chroot_dir):
            raise Fail(f"{self.chroot_dir} already exists")

    def create(self, suite: str):
        """
        Create a new chroot.

        The last creation command is run with exec, so this function, when
        successful, never returns and destroys the calling process
        """
        raise NotImplementedError(f"{self.__class__.__name__}.create not implemented")

    def maintenance_login(self):
        """
        Directly log into the chroot, without an ephemeral layer.

        This can be used to perform maintenance on the chroot.

        Login is done with exec, so this function, when successful, never
        returns and destroys the calling process
        """
        cmd = ["systemd-nspawn", "--directory", self.chroot_dir]
        log.info("Running %s", " ".join(shlex.quote(c) for c in cmd))
        os.execvp(cmd[0], cmd)


class OverlayChroot(Chroot):
    """
    Chroot implemenation for traditional filesystems
    """
    def create(self, suite: str):
        cmd = ["debootstrap", "--variant=minbase", "--include=git,dbus,systemd",
               suite, self.chroot_dir]
        log.info("Running %s", " ".join(shlex.quote(c) for c in cmd))
        os.execvp(cmd[0], cmd)


class BtrfsChroot(Chroot):
    """
    Chroot implementation for btrfs fileystems
    """
    def create(self, suite: str):
        # Create subvolume for chroot
        cmd = ["btrfs", "subvolume", "create", self.chroot_dir]
        log.info("Running %s", " ".join(shlex.quote(c) for c in cmd))
        subprocess.run(cmd, check=True)

        cmd = ["debootstrap", "--variant=minbase", "--include=git,dbus,systemd",
               suite, self.chroot_dir]
        log.info("Running %s", " ".join(shlex.quote(c) for c in cmd))
        os.execvp(cmd[0], cmd)


class OverlayRunner(NspawnRunner):
    """
    nspawn-runner implementation that runs on traditional filesystem, using
    overlay mounts
    """
    def __init__(self, *args, **kw):
        super().__init__(*args, **kw)
        self.overlays_dir = os.path.join(self.root_dir, ".overlays")

    def setup(self):
        super().setup()
        os.makedirs(self.overlays_dir, exist_ok=True)

    def get_machine(self, run_id: str) -> "Machine":
        return OverlayMachine(self, run_id)

    def get_chroot(self, image_name: str) -> "Chroot":
        return OverlayChroot(self, image_name)


class BtrfsRunner(NspawnRunner):
    """
    nspawn-runner implementation optimized for btrfs filesystems
    """
    def get_machine(self, run_id: str) -> "Machine":
        return BtrfsMachine(self, run_id)

    def get_chroot(self, image_name: str) -> "Chroot":
        return BtrfsChroot(self, image_name)



#
# Command line front-end
#

class Command:
    # Command name (as used in command line)
    # Defaults to the lowercased class name
    NAME: Optional[str] = None

    # Command description (as used in command line help)
    # Defaults to the strip()ped class docstring.
    DESC: Optional[str] = None

    def __init__(self, args):
        self.args = args
        self.setup_logging()
        self.nspawn_runner = NspawnRunner.create("/var/lib/nspawn-runner")

    def setup_logging(self):
        # Setup logging
        FORMAT = "%(asctime)-15s %(levelname)s %(message)s"
        log_handler = logging.StreamHandler(sys.stderr)
        log_handler.setFormatter(logging.Formatter(FORMAT))
        if self.args.debug:
            log_handler.setLevel(logging.DEBUG)
        elif self.args.verbose:
            log_handler.setLevel(logging.INFO)
        else:
            log_handler.setLevel(logging.WARN)
        root_logger = logging.getLogger()
        root_logger.addHandler(log_handler)
        root_logger.setLevel(logging.DEBUG)

    @classmethod
    def get_name(cls):
        if cls.NAME is not None:
            return cls.NAME
        return cls.__name__.lower()

    @classmethod
    def make_subparser(cls, subparsers):
        desc = cls.DESC
        if desc is None:
            desc = cls.__doc__.strip()

        parser = subparsers.add_parser(cls.get_name(), help=desc)
        parser.set_defaults(handler=cls)
        return parser


class RunMixin:
    """
    Common implementation for commands that manage runs
    """
    @classmethod
    def make_subparser(cls, subparsers):
        default_id = os.environ.get("CUSTOM_ENV_CI_JOB_ID")

        parser = super().make_subparser(subparsers)
        parser.add_argument("--id", action="store", default=default_id,
                            help="ID for this CI run. Default: taken from $CUSTOM_ENV_CI_JOB_ID")
        return parser

    def __init__(self, *args, **kw):
        super().__init__(*args, **kw)

        if self.args.id is None:
            raise Fail("run ID not provided with --id and not found in the environment")

        self.machine = self.nspawn_runner.get_machine(self.args.id)


class SetupMixin:
    """
    Common implementation for commands that perform setups of chroots or runs
    """
    def __init__(self, *args, **kw):
        super().__init__(*args, **kw)
        self.nspawn_runner.setup()


class ChrootMixin:
    """
    Common implementation for commands that work with a chroot
    """
    @classmethod
    def make_subparser(cls, subparsers):
        parser = super().make_subparser(subparsers)
        parser.add_argument("image", action="store", nargs="?",
                            help="chroot name. Default: taken from $CUSTOM_ENV_CI_JOB_IMAGE")
        parser.add_argument("--default-image", action="store",
                            help="chroot name when image is not passed and $CUSTOM_ENV_CI_JOB_IMAGE is not set")
        return parser

    def __init__(self, *args, **kw):
        super().__init__(*args, **kw)
        image = self.args.image
        if image is None:
            image = os.environ.get("CUSTOM_ENV_CI_JOB_IMAGE")
        if image is None:
            image = self.args.default_image
        if image is None:
            raise Fail("Please provide an image name, or set $CUSTOM_ENV_CI_JOB_IMAGE")
        image = os.path.basename(image)
        if image.startswith("."):
            raise Fail("Image names cannot start with '.'")

        self.chroot = self.nspawn_runner.get_chroot(image)


class ChrootCreate(ChrootMixin, SetupMixin, Command):
    """
    create a chroot that serves as a base for ephemeral machines
    """
    NAME = "chroot-create"

    @classmethod
    def make_subparser(cls, subparsers):
        parser = super().make_subparser(subparsers)
        parser.add_argument("--suite", action="store", default="buster",
                            help="debootstrap suite. Default: %(default)s)")
        return parser

    def run(self):
        self.chroot.must_not_exist()
        self.chroot.create(self.args.suite)


class ChrootLogin(ChrootMixin, Command):
    """
    enter the chroot to perform maintenance
    """
    NAME = "chroot-login"

    def run(self):
        self.chroot.must_exist()
        self.chroot.maintenance_login()


class Prepare(ChrootMixin, SetupMixin, RunMixin, Command):
    """
    start an ephemeral system for a CI run
    """
    def run(self):
        self.chroot.must_exist()
        self.machine.start(self.chroot)


class Run(RunMixin, Command):
    """
    run a command inside a CI machine
    """
    @classmethod
    def make_subparser(cls, subparsers):
        parser = super().make_subparser(subparsers)
        parser.add_argument("--shell", action="store", default="/bin/bash",
                            help="shell to use to run the script. Default: $(default)s")
        parser.add_argument("script", action="store",
                            help="script to run")
        parser.add_argument("description", action="store", nargs="?",
                            help="optional description for this script")
        return parser

    def run(self):
        self.machine.run(self.args.shell, self.args.script)


class Cleanup(RunMixin, Command):
    """
    cleanup a CI machine after it's run
    """
    def run(self):
        self.machine.terminate()


class GitlabConfig(Command):
    """
    configuration step for gitlab-runner
    """
    NAME = "gitlab-config"

    def run(self):
        # Nothing to do
        pass


class Toml(Command):
    """
    output the toml configuration for the custom runner
    """
    def run(self):
        argv0 = os.path.abspath(sys.argv[0])
        print(f'[[runners]]')
        print(f'  name="nspawn-runner"')
        print(f'  url="TODO"')
        print(f'  token="TODO"')
        print(f'  executor = "custom"')
        print(f'  builds_dir = "{self.gitlab_build_dir}"')
        print(f'  cache_dir = "{self.gitlab_cache_dir}"')
        print(f'  [runners.custom_build_dir]')
        print(f'  [runners.cache]')
        print(f'    [runners.cache.s3]')
        print(f'    [runners.cache.gcs]')
        print(f'    [runners.cache.azure]')
        print(f'  [runners.custom]')
        print(f'    config_exec = "{argv0}"')
        print(f'    config_args = ["gitlab-config"]')
        print(f'    config_exec_timeout = 200')
        print(f'    prepare_exec = "{argv0}"')
        print(f'    prepare_args = ["prepare"]')
        print(f'    prepare_exec_timeout = 200')
        print(f'    run_exec = "{argv0}"')
        print(f'    run_args = ["run"]')
        print(f'    cleanup_exec = "{argv0}"')
        print(f'    cleanup_args = ["cleanup"]')
        print(f'    cleanup_exec_timeout = 200')
        print(f'    graceful_kill_timeout = 200')
        print(f'    force_kill_timeout = 200')


def main():
    parser = argparse.ArgumentParser(description="Manage systemd-nspawn machines for CI runs.")
    parser.add_argument("-v", "--verbose", action="store_true", help="verbose output")
    parser.add_argument("--debug", action="store_true", help="verbose output")
    subparsers = parser.add_subparsers(help="sub-command help", dest="command")

    ChrootCreate.make_subparser(subparsers)
    ChrootLogin.make_subparser(subparsers)
    Prepare.make_subparser(subparsers)
    Run.make_subparser(subparsers)
    Cleanup.make_subparser(subparsers)
    GitlabConfig.make_subparser(subparsers)
    Toml.make_subparser(subparsers)

    args = parser.parse_args()
    handler = args.handler(args)

    res = handler.run()
    if res is not None:
        sys.exit(res)


if __name__ == "__main__":
    try:
        main()
    except Fail as e:
        print(e, file=sys.stderr)
        # Use $SYSTEM_FAILURE_EXIT_CODE as exit code if provided
        exit_code = int(os.environ.get("SYSTEM_FAILURE_EXIT_CODE", 1))
        sys.exit(exit_code)
    except Success:
        pass
    except Exception:
        import traceback
        traceback.print_exc()
        # Use $SYSTEM_FAILURE_EXIT_CODE as exit code if provided
        exit_code = int(os.environ.get("SYSTEM_FAILURE_EXIT_CODE", 1))
        sys.exit(exit_code)
