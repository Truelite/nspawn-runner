#!/usr/bin/env python3

from __future__ import annotations
from typing import Optional
import argparse
import logging
import subprocess
import os
import sys
import shlex
import shutil

log = logging.getLogger("nspawn-runner")


class Fail(RuntimeError):
    """
    Exception raised when the program should exit with an error but without a
    backtrace
    """
    pass


class Success(Exception):
    """
    Exception raised when a command has been successfully handled, and no
    further processing should happen
    """
    pass


class Command:
    # Command name (as used in command line)
    # Defaults to the lowercased class name
    NAME: Optional[str] = None

    # Command description (as used in command line help)
    # Defaults to the strip()ped class docstring.
    DESC: Optional[str] = None

    def __init__(self, args):
        self.args = args
        self.setup_logging()
        self.root_dir = "/var/lib/nspawn-runner"
        self.overlays_dir = os.path.join(self.root_dir, ".overlays")
        self.gitlab_build_dir = os.path.join(self.root_dir, ".build")
        self.gitlab_cache_dir = os.path.join(self.root_dir, ".cache")

    def setup_logging(self):
        # Setup logging
        FORMAT = "%(asctime)-15s %(levelname)s %(message)s"
        log_handler = logging.StreamHandler(sys.stderr)
        log_handler.setFormatter(logging.Formatter(FORMAT))
        if self.args.debug:
            log_handler.setLevel(logging.DEBUG)
        elif self.args.verbose:
            log_handler.setLevel(logging.INFO)
        else:
            log_handler.setLevel(logging.WARN)
        root_logger = logging.getLogger()
        root_logger.addHandler(log_handler)
        root_logger.setLevel(logging.DEBUG)

    @classmethod
    def get_name(cls):
        if cls.NAME is not None:
            return cls.NAME
        return cls.__name__.lower()

    @classmethod
    def make_subparser(cls, subparsers):
        desc = cls.DESC
        if desc is None:
            desc = cls.__doc__.strip()

        parser = subparsers.add_parser(cls.get_name(), help=desc)
        parser.set_defaults(handler=cls)
        return parser


class RunMixin:
    """
    Common implementation for commands that manage runs
    """
    @classmethod
    def make_subparser(cls, subparsers):
        default_id = os.environ.get("CUSTOM_ENV_CI_JOB_ID")

        parser = super().make_subparser(subparsers)
        parser.add_argument("--id", action="store", default=default_id,
                            help="ID for this CI run. Default: taken from $CUSTOM_ENV_CI_JOB_ID")
        return parser

    def __init__(self, *args, **kw):
        super().__init__(*args, **kw)

        if self.args.id is None:
            raise Fail("run ID not provided with --id and not found in the environment")

        self.machine_name = f"run-{self.args.id}"
        self.overlay_dir = os.path.join(self.overlays_dir, self.machine_name)


class SetupMixin:
    """
    Common implementation for commands that perform setups of chroots or runs
    """
    def __init__(self, *args, **kw):
        super().__init__(*args, **kw)
        os.makedirs(self.root_dir, exist_ok=True)
        os.makedirs(self.overlays_dir, exist_ok=True)
        os.makedirs(self.gitlab_build_dir, exist_ok=True)
        os.makedirs(self.gitlab_cache_dir, exist_ok=True)


class ChrootMixin:
    """
    Common implementation for commands that work with a chroot
    """
    @classmethod
    def make_subparser(cls, subparsers):
        parser = super().make_subparser(subparsers)
        parser.add_argument("image", action="store", nargs="?",
                            help="chroot name (default: taken from $CUSTOM_ENV_CI_JOB_IMAGE")
        parser.add_argument("--default-image", action="store",
                            help="chroot name when image is not passed and $CUSTOM_ENV_CI_JOB_IMAGE is not set")
        return parser

    def __init__(self, *args, **kw):
        super().__init__(*args, **kw)
        image = self.args.image
        if image is None:
            image = os.environ.get("CUSTOM_ENV_CI_JOB_IMAGE")
        if image is None:
            image = self.args.default_image
        if image is None:
            raise Fail("Please provide --image or set $CUSTOM_ENV_CI_JOB_IMAGE")
        image = os.path.basename(image)
        if image.startswith("."):
            raise Fail("Image names cannot start with '.'")
        self.image_name = image
        self.chroot_dir = os.path.join(self.root_dir, image)


class ChrootCreate(ChrootMixin, SetupMixin, Command):
    """
    create a chroot that serves as a base for ephemeral machines
    """
    NAME = "chroot-create"

    @classmethod
    def make_subparser(cls, subparsers):
        parser = super().make_subparser(subparsers)
        parser.add_argument("--suite", action="store", default="buster",
                            help="debootstrap suite")
        return parser

    def run(self):
        if os.path.exists(self.chroot_dir):
            raise Fail(f"{self.chroot_dir} already exists")
        cmd = ["debootstrap", "--variant=minbase", "--include=git,dbus,systemd",
               self.args.suite, self.chroot_dir]
        log.info("Running %s", " ".join(shlex.quote(c) for c in cmd))
        os.execvp(cmd[0], cmd)


class ChrootLogin(ChrootMixin, Command):
    """
    enter the chroot to perform maintenance
    """
    NAME = "chroot-login"

    def run(self):
        if not os.path.exists(self.chroot_dir):
            raise Fail(f"{self.chroot_dir} does not exist")
        cmd = ["systemd-nspawn", "--directory", self.chroot_dir]
        log.info("Running %s", " ".join(shlex.quote(c) for c in cmd))
        os.execvp(cmd[0], cmd)


class Prepare(ChrootMixin, SetupMixin, RunMixin, Command):
    """
    start an ephemeral system for a CI run
    """
    def run(self):
        log.info("Starting machine using image %s", self.image_name)
        if not os.path.exists(self.chroot_dir):
            available = sorted(x for x in os.listdir(self.root_dir) if not x.startswith("."))
            raise Fail(f"{self.chroot_dir} does not exist. Use one of {', '.join(available)}")

        if os.path.exists(self.overlay_dir):
            raise Fail(f"overlay directory {self.overlay_dir} already exists")
        os.makedirs(self.overlay_dir, exist_ok=True)

        unit_config = [
            'KillMode=mixed',
            'Type=notify',
            'RestartForceExitStatus=133',
            'SuccessExitStatus=133',
            'Slice=machine.slice',
            'Delegate=yes',
            'TasksMax=16384',
            'WatchdogSec=3min',
        ]

        cmd = ["systemd-run"]
        for c in unit_config:
            cmd.append("-p")
            cmd.append(c)

        cmd.extend(
            ("systemd-nspawn",
                "--quiet",
                f"--directory={self.chroot_dir}",
                f"--overlay={self.chroot_dir}:{self.overlay_dir}:/",
                f"--machine={self.machine_name}",
                "--boot",
                "--notify-ready=yes")
        )

        log.info("Running %s", " ".join(shlex.quote(c) for c in cmd))
        os.execvp(cmd[0], cmd)


class Run(RunMixin, Command):
    """
    run a command inside a CI machine
    """
    @classmethod
    def make_subparser(cls, subparsers):
        parser = super().make_subparser(subparsers)
        parser.add_argument("--shell", action="store", default="/bin/bash",
                            help="shell to use to run the script. Default: $(default)s")
        parser.add_argument("script", action="store",
                            help="script to run")
        parser.add_argument("description", action="store", nargs="?",
                            help="optional description for this script")
        return parser

    def run(self):
        cmd = [
            "systemd-run", "--quiet", "--pipe", "--wait",
            f"--machine={self.machine_name}", self.args.shell
        ]

        log.info("Running %s", " ".join(shlex.quote(c) for c in cmd))
        with open(self.args.script, "rb") as fd:
            res = subprocess.run(cmd, stdin=fd)

        if res.returncode != 0:
            raise Fail(f"Run script exited with code {res.returncode}")


class Cleanup(RunMixin, Command):
    """
    cleanup a CI machine after it's run
    """
    def run(self):
        try:
            res = subprocess.run(["machinectl", "terminate", self.machine_name])
            if res.returncode != 0:
                raise Fail(f"Run script exited with code {res.returncode}")
        finally:
            if os.path.exists(self.overlay_dir):
                shutil.rmtree(self.overlay_dir)


class GitlabConfig(Command):
    """
    configuration step for gitlab-runner
    """
    NAME = "gitlab-config"

    def run(self):
        # Nothing to do
        pass


class Toml(Command):
    """
    output the toml configuration for the custom runner
    """
    def run(self):
        argv0 = os.path.abspath(sys.argv[0])
        print(f'[[runners]]')
        print(f'  name="nspawn-runner"')
        print(f'  url="TODO"')
        print(f'  token="TODO"')
        print(f'  executor = "custom"')
        print(f'  builds_dir = "{self.gitlab_build_dir}"')
        print(f'  cache_dir = "{self.gitlab_cache_dir}"')
        print(f'  [runners.custom_build_dir]')
        print(f'  [runners.cache]')
        print(f'    [runners.cache.s3]')
        print(f'    [runners.cache.gcs]')
        print(f'    [runners.cache.azure]')
        print(f'  [runners.custom]')
        print(f'    config_exec = "{argv0}"')
        print(f'    config_args = ["gitlab-config"]')
        print(f'    config_exec_timeout = 200')
        print(f'    prepare_exec = "{argv0}"')
        print(f'    prepare_args = ["prepare"]')
        print(f'    prepare_exec_timeout = 200')
        print(f'    run_exec = "{argv0}"')
        print(f'    run_args = ["run"]')
        print(f'    cleanup_exec = "{argv0}"')
        print(f'    cleanup_args = ["cleanup"]')
        print(f'    cleanup_exec_timeout = 200')
        print(f'    graceful_kill_timeout = 200')
        print(f'    force_kill_timeout = 200')


def main():
    parser = argparse.ArgumentParser(description="Manage systemd-nspawn machines for CI runs.")
    parser.add_argument("-v", "--verbose", action="store_true", help="verbose output")
    parser.add_argument("--debug", action="store_true", help="verbose output")
    subparsers = parser.add_subparsers(help="sub-command help", dest="command")

    ChrootCreate.make_subparser(subparsers)
    ChrootLogin.make_subparser(subparsers)
    Prepare.make_subparser(subparsers)
    Run.make_subparser(subparsers)
    Cleanup.make_subparser(subparsers)
    GitlabConfig.make_subparser(subparsers)
    Toml.make_subparser(subparsers)

    args = parser.parse_args()
    handler = args.handler(args)

    res = handler.run()
    if res is not None:
        sys.exit(res)


if __name__ == "__main__":
    try:
        main()
    except Fail as e:
        print(e, file=sys.stderr)
        # Use $SYSTEM_FAILURE_EXIT_CODE as exit code if provided
        exit_code = int(os.environ.get("SYSTEM_FAILURE_EXIT_CODE", 1))
        sys.exit(exit_code)
    except Success:
        pass
    except Exception:
        import traceback
        traceback.print_exc()
        # Use $SYSTEM_FAILURE_EXIT_CODE as exit code if provided
        exit_code = int(os.environ.get("SYSTEM_FAILURE_EXIT_CODE", 1))
        sys.exit(exit_code)
